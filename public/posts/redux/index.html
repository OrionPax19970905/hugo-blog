<!DOCTYPE html>
<html lang="zh-cn" >
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  
  <meta name="author"
        content="OrionPax"/>

  
  <meta name="description" content="简介 Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 三大原则 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的（可预测性） 唯一改变 state 的方法就是触发 action，action"/>
  

  
  
  <meta name="keywords" content="OrionPax, Java 开发, Hugo, zozo"/>
  

  
  <link rel="canonical" href="http://blog.orionpax.top/posts/redux/"/>

  

  <title>Redux 学习笔记 &middot; OrionPax 的个人博客</title>

  <link rel="shortcut icon" href="http://blog.orionpax.top/images/favicon.ico"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/animate.min.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/remixicon.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/zozo.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/highlight.css"/>

  
  
</head>

<body>
<div class="main animated">
  <div class="nav_container animated fadeInDown">
  <div class="site_nav" id="site_nav">
    <ul>
      
      <li>
        <a href="/">首页</a>
      </li>
      
      <li>
        <a href="/posts/">归档</a>
      </li>
      
      <li>
        <a href="/tags/">标签</a>
      </li>
      
      <li>
        <a href="/skills.png">技能树</a>
      </li>
      
      <li>
        <a href="/tools.png">工具栈</a>
      </li>
      
    </ul>
  </div>
  <div class="menu_icon">
    <a id="menu_icon"><i class="remixicon-links-line"></i></a>
  </div>
</div>

  <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <h1>
        <a href="http://blog.orionpax.top">
          <span>OrionPax 的个人博客</span>
          <img src="http://blog.orionpax.top/images/logo.svg"/>
        </a>
      </h1>
    </div>
    <div class="description">
      <p class="sub_title"></p>
      <div class="my_socials">
        
        
        <a href="https://github.com/OrionPax19970905" title="github" target="_blank"><i class="remixicon-github-fill"></i></a>
        
        
        
        <a href="OrionPax19970905@gmail.com" title="gmail" target="_blank"><i class="remixicon-gmail-fill"></i></a>
        
        
        <a href="http://blog.orionpax.top/index.xml" type="application/rss+xml" title="rss" target="_blank"><i class="remixicon-rss-fill"></i></a>
      </div>
    </div>
  </div>
</div>

  <div class="content">
    <div class="post_page">
      <div class="post animated fadeInDown">
        <div class="post_title post_detail_title">
          <h2><a href='/posts/redux/'>Redux 学习笔记</a></h2>
          <span class="date">2019.07.23</span>
        </div>
        <div class="post_content markdown">

<h1 id="简介">简介</h1>

<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>

<h1 id="三大原则">三大原则</h1>

<ul>
<li>单一数据源
整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>
<li>State 是只读的（可预测性）
唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象(state + action = new state)。</li>
<li>使用纯函数来执行修改
为了描述 action 如何改变 state tree ，你需要编写 reducers。输入相同，输出一定相同。</li>
</ul>

<h1 id="基础">基础</h1>

<h2 id="action">Action</h2>

<p>Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>

<pre><code>const ADD_TODO = 'ADD_TODO';

//添加新 todo 任务的 action 是这样的：
{
  type: ADD_TODO,
  text: 'Build my first Redux app'
}

</code></pre>

<h2 id="reducer">Reducer</h2>

<p>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。</p>

<h2 id="store">Store</h2>

<ul>
<li>getState() : 返回应用当前的 state 树。</li>
<li>dispatch(action) : 分发 action。这是触发 state 变化的惟一途径。</li>
<li>subscribe(listener) : 添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。</li>
</ul>

<h1 id="api">API</h1>

<h2 id="createstore-reducer-preloadedstate-enhancer">createStore(reducer, [preloadedState], enhancer)</h2>

<p>创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。</p>

<h2 id="combinereducers-reducers">combineReducers(reducers)</h2>

<p>随着应用变得越来越复杂，可以考虑将 reducer 函数 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。</p>

<h2 id="bindactioncreators-actioncreators-dispatch">bindActionCreators(actionCreators, dispatch)</h2>

<p>把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。</p>

<h1 id="react-redux-api">react-redux API</h1>

<h2 id="provider-store"><Provider store></h2>

<p><Provider store> 使组件层级中的 connect() 方法都能够获得 Redux store。</p>

<h2 id="connect-mapstatetoprops-mapdispatchtoprops-mergeprops-options">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h2>

<ul>
<li>连接 React 组件与 Redux store。</li>
<li><a href="Function">mapStateToProps(state, [ownProps]): stateProps</a>: 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。</li>
<li><a href="Object or Function">mapDispatchToProps(dispatch, [ownProps]): dispatchProps</a>: 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中 dispatch 方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。</li>
</ul>

<h1 id="不可变数据">不可变数据</h1>

<h2 id="为什么需要不可变数据">为什么需要不可变数据</h2>

<ul>
<li>性能优化(引用比较)</li>
<li>易于调试和跟踪(计算 diff 值)</li>
<li>易于推测</li>
</ul>

<h2 id="如何操作不可变数据">如何操作不可变数据</h2>

<ul>
<li><p>原生写法</p>

<pre><code>//性能最高
const state = { filter: &quot;completed&quot;, todos: [&quot;Learn React&quot;] };

const newState = { ...state, todos: [...state.todos, &quot;Learn Redux&quot;] };

const newState2 = Object.assign({}, state, {
todos: [...state.todos, &quot;Learn Redux&quot;]
});
</code></pre></li>

<li><p>immutability-helper</p>

<pre><code>//深层次的不可变数据方便
import update from 'immutability-helper';

const state = {filter : &quot;completed&quot;, todos: [&quot;Learn React&quot;]};

const newState = update(state, { todos: {$push: [&quot;Learn Redux&quot;]});
</code></pre></li>

<li><p>immer</p>

<pre><code>//可读性强，性能层次较深的话会较低
import produce from &quot;immer&quot;;

const state = { filter: &quot;completed&quot;, todos: [&quot;Learn React&quot;] };

const newState = produce(state, drafState =&gt; {
drafState.todos.push(&quot;Learn Redux&quot;);
});
</code></pre></li>
</ul>
</div>
        <div class="post_footer">
          
          <div class="meta">
            <div class="info">
              <span class="field tags">
                <i class="remixicon-stack-line"></i>
                
                <a href="http://blog.orionpax.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                
                <a href="http://blog.orionpax.top/tags/redux/">Redux</a>
                
              </span>
            </div>
          </div>
          
        </div>
      </div>
      
      
      
<div class="doc_comments">
  <div class="comments_block_title">发表评论</div>
  <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="http://blog.orionpax.top/css/comments.css"/>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
new Valine({
  el: '#vcomments',
  appId: 'nW05u87yweVedDRhj6AUgzR1-gzGzoHsz',
  appKey: '4HgKbiggTv7ocU789S5WO6ov',
  placeholder: '确定不说点什么?',
  visitor: 'true',
})
</script>

      
    </div>
  </div>
  <a id="back_to_top" href="#" class="back_to_top"><span>△</span></a>
</div>
<footer class="footer">
  <div class="powered_by">
    <a href="https://zeuk.me">Designed by Zeuk,</a>
    <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
  </div>

  <div class="footer_slogan">
    <span>不能记住过去的人，被判重复过去。</span>
  </div>
</footer>



<script src="http://blog.orionpax.top/js/jquery-3.3.1.min.js"></script>
<script src="http://blog.orionpax.top/js/zozo.js"></script>
<script src="http://blog.orionpax.top/js/highlight.pack.js"></script>
<link  href="http://blog.orionpax.top/css/fancybox.min.css" rel="stylesheet">
<script src="http://blog.orionpax.top/js/fancybox.min.js"></script>

<script>hljs.initHighlightingOnLoad()</script>


  <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>






</body>
</html>
