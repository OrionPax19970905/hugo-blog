<!DOCTYPE html>
<html lang="zh-cn" >
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  
  <meta name="author"
        content="OrionPax"/>

  
  <meta name="description" content="简单使用 简介 什么是 TypeScript? TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。 为什么选择 TypeScript? TypeScript 增加了代码的可读性和可维护性 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（C"/>
  

  
  
  <meta name="keywords" content="OrionPax, Java 开发, Hugo, zozo"/>
  

  
  <link rel="canonical" href="http://blog.orionpax.top/posts/typescript/"/>

  

  <title>TypeScript 学习笔记 &middot; OrionPax 的个人博客</title>

  <link rel="shortcut icon" href="http://blog.orionpax.top/images/favicon.ico"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/animate.min.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/remixicon.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/zozo.css"/>
  <link rel="stylesheet" href="http://blog.orionpax.top/css/highlight.css"/>

  
  
</head>

<body>
<div class="main animated">
  <div class="nav_container animated fadeInDown">
  <div class="site_nav" id="site_nav">
    <ul>
      
      <li>
        <a href="/">首页</a>
      </li>
      
      <li>
        <a href="/posts/">归档</a>
      </li>
      
      <li>
        <a href="/tags/">标签</a>
      </li>
      
      <li>
        <a href="/skills.png">技能树</a>
      </li>
      
      <li>
        <a href="/tools.png">工具栈</a>
      </li>
      
    </ul>
  </div>
  <div class="menu_icon">
    <a id="menu_icon"><i class="remixicon-links-line"></i></a>
  </div>
</div>

  <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <h1>
        <a href="http://blog.orionpax.top">
          <span>OrionPax 的个人博客</span>
          <img src="http://blog.orionpax.top/images/logo.svg"/>
        </a>
      </h1>
    </div>
    <div class="description">
      <p class="sub_title"></p>
      <div class="my_socials">
        
        
        <a href="https://github.com/OrionPax19970905" title="github" target="_blank"><i class="remixicon-github-fill"></i></a>
        
        
        
        <a href="OrionPax19970905@gmail.com" title="gmail" target="_blank"><i class="remixicon-gmail-fill"></i></a>
        
        
        <a href="http://blog.orionpax.top/index.xml" type="application/rss+xml" title="rss" target="_blank"><i class="remixicon-rss-fill"></i></a>
      </div>
    </div>
  </div>
</div>

  <div class="content">
    <div class="post_page">
      <div class="post animated fadeInDown">
        <div class="post_title post_detail_title">
          <h2><a href='/posts/typescript/'>TypeScript 学习笔记</a></h2>
          <span class="date">2019.07.25</span>
        </div>
        <div class="post_content markdown">

<h2 id="简单使用">简单使用</h2>

<h3 id="简介">简介</h3>

<h4 id="什么是-typescript">什么是 TypeScript?</h4>

<p><a href="http://www.typescriptlang.org">TypeScript</a> 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。</p>

<h4 id="为什么选择-typescript">为什么选择 TypeScript?</h4>

<ul>
<li>TypeScript 增加了代码的可读性和可维护性</li>
<li>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li>
<li>可能和一些库结合的不是很完美</li>
</ul>

<h3 id="基础">基础</h3>

<h4 id="原始数据类型">原始数据类型</h4>

<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。</p>

<pre><code>let isDone: boolean = false;
let decLiteral: number = 6;
let myName: string = 'Tom';
let u: undefined = undefined;
let n: null = null;
// JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数
function alertName(): void {
    alert('My name is Tom');
}
</code></pre>

<h4 id="任意值">任意值</h4>

<pre><code>// 如果是一个普通类型，在赋值过程中改变类型是不被允许的 error TS2322: Type 'number' is not assignable to type 'string'.
let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;

// 但如果是 any 类型，则允许被赋值为任意类型
let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7;

// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型
let something;
// 等价于
let something: any;
</code></pre>

<ul>
<li>在任意值上访问任何属性都是允许的</li>
<li>也允许调用任何方法</li>
<li>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</li>
</ul>

<h4 id="类型推论">类型推论</h4>

<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。其实就是根据初始化的值来确认类型，不进行初始化就是 any</p>

<h4 id="接口">接口</h4>

<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>

<pre><code>// 简单的例子 定义的变量的属性必须和接口保持一致，多或少都是不可以的。赋值的时候，变量的形状必须和接口的形状保持一致。
interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
</code></pre>

<pre><code>// 可选属性 仍然不允许添加未定义的属性
interface Person {
    name: string;
    age?: number; // 这个属性是可选的
}
</code></pre>

<h4 id="数组的类型">数组的类型</h4>

<pre><code>// 「类型 + 方括号」表示法
let fibonacci: number[] = [1, 1, 2, 3, 5];

// 数组泛型
let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];

// 用接口表示数组
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];
</code></pre>

<h4 id="函数的类型">函数的类型</h4>

<pre><code>// 简单的函数定义 声明式
function sum(x: number, y: number): number {
    return x + y;
}

// 函数表达式定义函数 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。
let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};

// 箭头函数语法糖
let mySum: (x: number, y: number) =&gt; number = (x: number, y: number): number =&gt; {
    return x + y;
};

// 用接口定义函数的形状
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}

// 可选参数 可选参数后面不允许再出现必须参数
function buildName(firstName: string, lastName?: string) {
    ...
}

// 剩余参数
function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
}

// 重载 TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
    ...
}
</code></pre>

<h4 id="类型断言">类型断言</h4>

<p>将一个联合类型的变量指定为一个更加具体的类型。类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。</p>

<pre><code>&lt;类型&gt;值
// or
值 as 类型 // 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用这一种
</code></pre>

<h4 id="声明文件">声明文件</h4>

<p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>

<pre><code>// 相关语法
declare var // 声明全局变量
declare function // 声明全局方法
declare class // 声明全局类
declare enum // 声明全局枚举类型
declare namespace // 声明（含有子属性的）全局对象
interface 和 type // 声明全局类型
export // 导出变量
export namespace // 导出（含有子属性的）对象
export default ES6 // 默认导出
export = commonjs // 导出模块
export as namespace UMD // 库声明全局变量
declare global // 扩展全局变量
declare module // 扩展模块
/// &lt;reference /&gt; 三斜线指令
</code></pre>

<blockquote>
<p><a href="https://ts.xcatliu.com/basics/declaration-files">TypeScript 声明文件使用</a></p>
</blockquote>

<h3 id="进阶">进阶</h3>

<h4 id="类型别名">类型别名</h4>

<pre><code>// 简单的例子 类型别名常用于联合类型
type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    } else {
        return n();
    }
}
</code></pre>

<h4 id="字符串字面量类型">字符串字面量类型</h4>

<pre><code>// 字符串字面量类型用来约束取值只能是某几个字符串中的一个。类型别名与字符串字面量类型都是使用 type 进行定义。
type EventNames = 'click' | 'scroll' | 'mousemove';
function handleEvent(ele: Element, event: EventNames) {
    // do something
}
</code></pre>

<h4 id="类">类</h4>

<pre><code>// 属性和方法
// 使用 class 定义类，使用 constructor 定义构造函数。
class Animal {
    constructor(name) {
        this.name = name;
    }
    sayHi() {
        return `My name is ${this.name}`;
    }
}

let a = new Animal('Jack'); // 通过 new 生成新实例的时候，会自动调用构造函数。
console.log(a.sayHi()); // My name is Jack
</code></pre>

<pre><code>// 类的继承 子类中使用 super 关键字来调用父类的构造函数和方法
class Cat extends Animal {
    constructor(name) {
        super(name); // 调用父类的 constructor(name)
        console.log(this.name);
    }
    sayHi() {
        return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi()
    }
}
</code></pre>

<pre><code>// 存取器 getter 和 setter 可以改变属性的赋值和读取行为
class Animal {
    constructor(name) {
        this.name = name;
    }
    get name() {
        return 'Jack';
    }
    set name(value) {
        console.log('setter: ' + value);
    }
}

let a = new Animal('Kitty'); // setter: Kitty
a.name = 'Tom'; // setter: Tom
console.log(a.name); // Jack
</code></pre>

<pre><code>// 静态方法
class Animal {
    static isAnimal(a) {
        return a instanceof Animal;
    }
}
</code></pre>

<h4 id="类与接口">类与接口</h4>

<pre><code>interface Alarm {
    alert();
}

class Door {
}

class SecurityDoor extends Door implements Alarm {
    alert() {
        console.log('SecurityDoor alert');
    }
}

class Car implements Alarm {
    alert() {
        console.log('Car alert');
    }
}
</code></pre>
</div>
        <div class="post_footer">
          
          <div class="meta">
            <div class="info">
              <span class="field tags">
                <i class="remixicon-stack-line"></i>
                
                <a href="http://blog.orionpax.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                
                <a href="http://blog.orionpax.top/tags/typescript/">TypeScript</a>
                
              </span>
            </div>
          </div>
          
        </div>
      </div>
      
      
      
<div class="doc_comments">
  <div class="comments_block_title">发表评论</div>
  <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="http://blog.orionpax.top/css/comments.css"/>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
new Valine({
  el: '#vcomments',
  appId: 'nW05u87yweVedDRhj6AUgzR1-gzGzoHsz',
  appKey: '4HgKbiggTv7ocU789S5WO6ov',
  placeholder: '确定不说点什么?',
  visitor: 'true',
})
</script>

      
    </div>
  </div>
  <a id="back_to_top" href="#" class="back_to_top"><span>△</span></a>
</div>
<footer class="footer">
  <div class="powered_by">
    <a href="https://zeuk.me">Designed by Zeuk,</a>
    <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
  </div>

  <div class="footer_slogan">
    <span>不能记住过去的人，被判重复过去。</span>
  </div>
</footer>



<script src="http://blog.orionpax.top/js/jquery-3.3.1.min.js"></script>
<script src="http://blog.orionpax.top/js/zozo.js"></script>
<script src="http://blog.orionpax.top/js/highlight.pack.js"></script>
<link  href="http://blog.orionpax.top/css/fancybox.min.css" rel="stylesheet">
<script src="http://blog.orionpax.top/js/fancybox.min.js"></script>

<script>hljs.initHighlightingOnLoad()</script>


  <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>






</body>
</html>
